christophe portneuve
prof de programmation de Fabrice (ami a Olivier)
cours git: https://www.youtube.com/watch?v=ypR-rEBCoag

crwdsec : logiciel opensource cybersecurite que l'on peut implementer soit meme

Triple Ref Pointers - Computerphile: methode pour les listes chainer optimiser
https://www.youtube.com/watch?v=0ZEX_l0DFK0

-----------------------------------------------------------------------
Reinitialiser brave/chrome
rm -rf ~/.config/google-chrome/Singleton*
rm -rf ~/.config/BraveSoftware/Brave-Browser/Singleton*
--------------------------------------------------------------------------

Voir Olivier pour execution (on ne verifie pas les fichiers avant dans le parsing)
mais apres les forks, dans l'exec

--------------------------------------------------------------------------
j'ai deux facons de faire:
    - soit je manipule les tokens avec les quotes dedans (squote, dquote et multiple squote et dquote)
         - en utilisant une fonction process str, qui va boucler sur les characteres et voir qu'elle fonction appliquer (pointeur de fonctions)
    - soit je garde ma structure actuelle et je manipule tout avec des filtres conditionnelles en fonction des informations contenu dans chaque token

Pour la methode 1:
// il me faut une fonction qui
cherche un caractere, si il le trouve alors il copie la chaine, la met dans la variable result,
puis faire l'operation desirer (soit pour le dollar, soit pour les quotes)
puis boucler sur ce processus pour chaque token

Pour la methode 2:
creer les filtres

la methode 2 n'est pas bien puisque l'on manipule les quotes et que l'on doit fusionner les tokens
mais apres on peut faire une fonction fusion, mais faut aussi implementer le fait de modifier les attributs, pourquoi pas !?

on test avec la methode 2 puis on implementeras la methode 1 plus tards si le temps, ou si la methode 2 ne fonctionne pas

--------------------------------------------------------------------------

ETAPE 2: OK
doc: https://opensource.com/article/17/6/bash-parameter-expansion
implementer l'affectation de variable et d'expansion pure
Lors de l'attribution d'une variable, son nom doit être composé uniquement de caractères alphanumériques 
et de traits de soulignement, et il ne peut pas commencer par un chiffre. 
Il ne peut y avoir aucun espace autour du signe égal ; 
le nom doit le précéder immédiatement et la valeur suivre immédiatement :

$ variable_1="my content"

Ce qui implique l'etape qui suit:
    - apres le dollar il faut que la syntaxe correspondent a celle de l'etape 2 pour car c'est le nom de 
    la variable d'environnement que l'on souhaite appeller

On gere ce cas ci infiner: 
doc: https://opensource.com/article/17/6/bash-parameter-expansion
si dans un token->str on a "${" alors on envoie un message disant: l'expander de gere pas ce cas.
il ne gere que l'expansion avec une chaine de caractere en lien avec les variables d'environnement 
et le caractere '?'

ETAPE 4: OK
    - creer une fonction pour parcourir le tableau env et verifier puis recuperer la variable d'environnement
    si il y en a une qui correspond

ETAPE 5:
Definir et implementer les filtres les plus importants:
- par exemple, echo' bonjour'
- si token->type_token == T_COMMAND et token->rstick_token == is_quote(token->str) etc..

ETAPE 6:
doc: https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html
    - gerer l'expansion du tilde
        expand tilde + et tilde -

ETAPE 7:
    - aller dans gerer_expand.txt et gerer les cas particulier qui se trouvent a l'interieur

--------------------------------------------------------------------------
cas a gerer pour l'expand
bash-5.1$ echo $HOME"fdsfgg" -> cas (1) particulier a gerer
/mnt/nfs/homes/edesaintfdsfgg
bash-5.1$ echo $HOME "fdsfgg" -> cas (2) classique gerer par echo et fonctionne avec mon lexing
/mnt/nfs/homes/edesaint fdsfgg
bash-5.1$ echo $HOME"fds    fgg" -> gerer par le cas (1)
/mnt/nfs/homes/edesaintfds    fgg
bash-5.1$ echo $HOME"$HOMEfds    fgg" -> gerer par le cas (1), bien verifier pas d'espaces supplementaires
/mnt/nfs/homes/edesaint    fgg
bash-5.1$ echo $HOME'$HOMEfds    fgg' -> pris en compte dans le cas (1)
/mnt/nfs/homes/edesaint$HOMEfds    fgg
bash-5.1$ echo $HOME"$HOME fds    fgg" -> gerer par le cas (1)
/mnt/nfs/homes/edesaint/mnt/nfs/homes/edesaint fds    fgg
bash-5.1$ echo $HOME"$HOME'fds    fgg" -> gerer par le cas (1)
/mnt/nfs/homes/edesaint/mnt/nfs/homes/edesaint'fds    fgg
bash-5.1$ echo $HOME"$HOME|'fds    fgg"
/mnt/nfs/homes/edesaint/mnt/nfs/homes/edesaint|'fds    fgg
bash-5.1$ echo $HOME"$HOME>'fds    fgg"
/mnt/nfs/homes/edesaint/mnt/nfs/homes/edesaint>'fds    fgg
bash-5.1$ echo $HOME"$HOME<'fds    fgg"
/mnt/nfs/homes/edesaint/mnt/nfs/homes/edesaint<'fds    fgg
bash-5.1$ export L=l
bash-5.1$ $Ls -la
bash: -la: command not found
bash-5.1$ $"L"s -la
bash: Ls: command not found
bash-5.1$ "$L"s -la

--------------------------------------------------------------------------
cas export doit etre gerer

bash-5.1$ export ^=h
bash: export: `^=h': not a valid identifier
bash-5.1$ export $h=h
bash: export: `=h': not a valid identifier
bash-5.1$ export $h=bonjour
bash: export: `=bonjour': not a valid identifier
bash-5.1$ export $h="bonjour"
bash: export: `=bonjour': not a valid identifier
bash-5.1$ 
----------------------------------------------------------------------------
a voir, les noms des fichiers ne sont pas bons
important: peut etre initialiser data, comme ca on le gere de a a z 
    et on est sur de ne pas avoir de problemes quand on lance plusieurs fois (l'executable minishell/ plusieurs commandes dans l'executable)
    car comme la variable data est dans la stack, il peut garder le pointeur tant que l'executable ./minishell n'est pas terminer
--------------------------------------------------------------------------
logique execution des process des commandes
si une seule commande (un node),
 si ce n'est pas un builtin, alors on execute un process enfant
 si builtin dans le process parent
si plusieurs commandes (plusieurs nodes)
 tout est executer dans les processus enfant
--------------------------------------------------------------------------
les builtins doivent print une erreur si fail

-------------------------------------------------------------------------
Si on trouve un de ces tokens on envoie un message d'erreur
"minishell> reserved word
(a implementer dans le parser, en verifiant que chaque token->str est different):
! case coproc do done elif else esac fi for function if in select then until while { } time [[ ]]
awk

ce cas ci ne fonctionne pas au niveau des redirections:
./minishell "echo |>ouou "
A REVOIR
-------------------------------------------------------------------------

cas du sujet:
exit 5 | exit 6
echo $?

si tu es dans le dossier
et que tu supprime le dossier
il ne faut pas qu'il crash

edesaint@bess-f2r5s4:~/42-cursus/final_minishell$ env -i bash
edesaint@bess-f2r5s4:/mnt/nfs/homes/edesaint/42-cursus/final_minishell$ env
PWD=/mnt/nfs/homes/edesaint/42-cursus/final_minishell
SHLVL=1
_=/usr/bin/env

env -i (doit tout supprimer ou laisser que quelques info)

------------------------------------------------------------------------
On compte le nombre de pipes,
puis on cree et on ajoute les nodes.
On obtient ainsi: une liste de noeuds qui correspondent au maillon separer par les pipes.

Cela inclut un parsing quasi parfait pour avoir les bons tokens.
par exemple si on a: echo bonjour'|' et (ce nest pas le cas ici)
mais supposons qu'on compte un pipe en trop, il faudras gerer le cas ou on s'est trompe
pour au moins que ca segfault pas.

Ce cas la ne fonctionne pas: a tester: cat <<< bonjour
il faut ignorer le <<<

-----------------------------------------------------------------------
DISCUSSION ROBIN KERJEAN (le 18 au soir)

modifier la structure redirections

verifie si la redirection est correcte ou pas avec une fonction systeme de pipex (acess) f_OK etc.
fd_open(la cible)
si la redirection est pas valide alors,detecte que tout le maillon va etre merdique
type du token: erreur
que y est une erreur ou pas, passer 

verifier un par un les tokens du maillon en cours
 et mettre a jour les differentes redirections (les reecrire pour le node en cours)
 passage unique en une seule fois: pour la gestion d'erreur (si une erreur a 1 ne plus la modifier apres meme
 si il y a une nouvelle erreur puisque le maillon est deja considerer comme etant une erreur)
 et mettre a jour redir_out par exemle si le type_token est une redirection
 exemple append et out c'est le meme truc a envoyer a l'execution

pour faire cela: reprendre la meme facon de faire que pour exec_tab
 attribut type : CMD(une commande qui n'est pas un builtin), builtin, erreur
 les commandes seront execute avec execve

 reprendre la structure de rokerjean github minishell (env_link etc.)

 voir test d'integration continue (avec le testeur avant de commit ou push sur le github)

 metaphore (code monkey) sans methode

 singletone (facon derive de faire une globale avec une variable static)
 variable globale (peut etre modifie de n'importe ou)=> pas secure
 spike

--------------------------------------------------------------------------------------
 DISCUSSION avec robin 20 JANVIER

 voir mode interactif quand le heredoc, gestion des signals